## Описание задачи
Реализация модуля по “парсингу” (далее по тексту Модуль) заметок пользователей, 
с целью нахождения ключевых слов (необходимо учесть: в дальнейшим планируется развитие парсера, расширение функционала: поиск токенов (token- фрагмент текста определенного формата без учета его положения относительно других фрагментов текста, хэштегов и т.п.)

На прикладном уровне, Модуль должен доступен как функция, 
пример: parse( text, callback ). Далее классика: там где нам это надо, мы вызываем parse( “*some new text of note*”, function ( err, res ) { /* working with result of parsing*/ } )

## Технические детали
Текст заметки может содержать HTML теги 
(все что находится внутри < и > нас не интересует), emoji и т.п.. 
Важны сами теги и контент внутри тега, пример:
`<div style="font-size: 14px; line-height: 21px; color: #e4e4e4" data-some1="some1" data-some2="some2">Какой-то текст</div>`
"Какой-то текст" для нас важен, остальное нет
У нас есть список ignore words - список слов, которые должны быть проигнорированы (пример: “что-то”, “какой-то”, “do”, “doesn’t” ... ). 
**В некоторых случаях это будет регулярные выражения.**
У нас есть настройки:
Минимальная длина слова, чтобы оно нас интересовал
Сколько символов от начала текста мы просматриваем ( 0 - весь текст)
Параметры по умолчанию зашиты в модуле
  parse( text, params, callback)
  parse( text, callback)
Предполагается использовать парсер при наличии нескольких подмодулей. 
Выбор подмодулей внести в параметры передаваемые в функцию. 
Например:
   `parse( text, { 
      hashtags: [tag1, tag2]
   }, callback )`

но результат всегда разбит на 

{
  keywords: {},
  hashtags: {},
  ...
}

Для текста `“About John… If John goes home in monday at 10pm, I’ll be happy!”`, 
слова “if”, “in”, “at”, “be”, “‘ll” -  входят в ignore words, а слово I нам не интересно, 
т.к. у нас настройка “Минимальная длина слова = 2”. 
Ожидаемый результат будет: 
`{ “about” : 1, “john” : 2, “goes” : 1, “home” : 1, “monday” : 1, “10pm” : 1, “happy” : 1 }`

## Требования к результату
Модуль обязательно должен быть реализован самодостаточным 
(работа модуля не должна зависеть от внешних факторов), 
т.е. чтобы была возможность использовать его как в составе сервиса на сервере,
так и в составе front-end SPA или при необходимости в составе “молотилки” при глобальном пересчете данных всех пользователей.
Внутренняя архитектура Модуля должна предусматривать суб-модульность для простого дальнейшего расширения или частично замены суб-модулей. (изначально будет только один модуль: поиск ключевых слов, далее мы добавляем суб-модули: поиск хеш-тегов, поиск токенов и т.п.). 
Предусмотреть (заложить в архитектуру) :
 - Логирование деятельности (уровни error warn info)
 - Метрики и профалинг
 - Асинхронную работу: пример, при поиске токенов, нам может понадобиться коллекция токенов пользователя, а это асинхронный запрос в сторонний сервис.

